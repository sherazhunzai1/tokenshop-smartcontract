// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";


contract TokenshopNFT is IERC2981, AccessControl, ERC721Enumerable {
    using Counters for Counters.Counter; // counters for marketplace
    using Strings for uint256;

    bytes32 private constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; //keccak256("MINTER_ROLE");
    bytes32 private constant CONTRACT_ROLE =
        0x364d3d7565c7a8300c96fd53e065d19b65848d7b23b3191adcd55621c744223c; //keccak256("CONTRACT_ROLE");
    // one or more smart contracts allowed to call the mint function, eg. the Marketplace contract

    Counters.Counter private actualTotalSupply; // total NFTs Minted including NFTs burn

    address payable public feeAccount; // marketplace fee account (EOA)
    uint24 private _primaryPlatformBPs; // precentage in BPs for primary sale
    uint24 private _secondaryPlatformBPs; // precentage in BPs for each NFT sale (for primary and secondary)
    string private _baseTokenURI; // Base URI

    mapping(uint256 => string) private _tokenURIs; // Optional mapping for token URIs
    mapping(uint256 => uint24) private tokenIdToArtistFee;
    mapping(uint256 => address) public artists; // token Id to artist mapping, used for sending fees to artist on secondary sales

    mapping(uint256 => bool) private secondarySale; // map token Id to bool indicating wether it has been sold before

    /**
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE` role.
     */
    function mint(
        string memory _tokenURI,
        address _to,
        uint24 _artistFee
    ) external onlyRole(MINTER_ROLE) {
        uint256 tokenId = actualTotalSupply.current();

        _mint(_to, tokenId); // using total supply as counter, since tokens cannot be burned we don't need a separate counter
        _setTokenURI(tokenId, _tokenURI); // set URI after minting
        artists[tokenId] = _to;
        if (_artistFee == 0) {
            // if artist does not selects the artsit fee make the default 5%
            _artistFee = 500;
        }
        tokenIdToArtistFee[tokenId] = _artistFee;
        actualTotalSupply.increment();
    }

    /**
     * @notice  only either auction or marketplace contract can call it to set tokenId as secondary sale.
     * @param _tokenId TokenshopERC721 NFTs' tokenId
     *
     */
    function setSecondarySale(uint256 _tokenId)
        external
        onlyRole(CONTRACT_ROLE)
    {
        secondarySale[_tokenId] = true;
    }

    /**
     * @notice setter function only callable by contract admin used to update primary sales fee
     * @param _bps is (basic points). it is in bps i.e (1% = 100bps)
     */
    function setPrimaryPlatformBPs(uint24 _bps)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        // solhint-disable-next-line
        require(_bps < 10000); // new bps should not be more than 10000. i.e 100%.
        _primaryPlatformBPs = _bps;
    }

    /**
     * @notice setter function only callable by contract admin used to update platform
     * @param _bps is (basic points). it is in bps i.e (1% = 100bps)
     */
    function setSecondaryPlatformBPs(uint24 _bps)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        // solhint-disable-next-line
        require(_bps < 10000); // new bps should not be more than 10000. i.e 100%.
        _secondaryPlatformBPs = _bps;
    }

    /**
     * @dev updates the royaltiesFee for given token
     * @param _tokenId is the id of the token to update
     * @param _fee is the new royaltiesFee for token
     */
    function modifyTokenRoyalities(uint256 _tokenId, uint24 _fee) external {
        require(msg.sender == artists[_tokenId], "not creator");
        tokenIdToArtistFee[_tokenId] = _fee;
    }

    /**
     * @notice setter function only callable by contract admin used to change the address to which fees are paid
     * @param _feeAccount is the address owned by marketplace that will collect sales fees
     */
    function setFeeAccount(address payable _feeAccount)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        feeAccount = _feeAccount;
    }

    /*****************************/
    /****** View Functions *******/
    /*****************************/

    function getStateInfo(uint256 tokenId)
        external
        view
        returns (
            address marketplaceFeeWallet,
            bool isSecondarySale,
            uint24 artistFee,
            uint24 primaryPlatformBPs,
            uint24 secondaryPlatformBPs,
            address artist
        )
    {
        marketplaceFeeWallet = feeAccount;
        isSecondarySale = secondarySale[tokenId];
        artistFee = tokenIdToArtistFee[tokenId];
        primaryPlatformBPs = _primaryPlatformBPs;
        secondaryPlatformBPs = _secondaryPlatformBPs;
        artist = artists[tokenId];
    }

    /**
     * Optional function to set the base URI
     */
    function setBaseURI(string memory baseURI_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _baseTokenURI = baseURI_;
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(tokenId),
            "TokenshopERC721: URI query for nonexistent token"
        );

        string memory _tokenURI = _tokenURIs[tokenId];
        string memory base = _baseURI();

        // If there is no base URI, return the token URI.
        if (bytes(base).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(base, _tokenURI));
        }

        return super.tokenURI(tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI)
        internal
        virtual
    {
        require(
            _exists(tokenId),
            "TokenshopERC721: URI set of nonexistent token"
        );
        _tokenURIs[tokenId] = _tokenURI;
    }

    function exists(uint256 tokenId) external view returns (bool) {
        return _exists(tokenId);
    }

    /**
     * @dev overrides the base function which is empty by default
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /// @inheritdoc	IERC2981
    function royaltyInfo(uint256 _tokenId, uint256 value)
        external
        view
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        require(_exists(_tokenId), "nonexistent token");
        uint24 artistsFee = tokenIdToArtistFee[_tokenId];
        receiver = artists[_tokenId];
        royaltyAmount = (value * artistsFee) / 10000;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, AccessControl, ERC721Enumerable)
        returns (bool)
    {
        return
            interfaceId == type(IERC2981).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI, // e.g. https://ipfs.io/ipfs/
        address _feeAccount
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        require(_feeAccount != address(0x0), "null fee account");
        feeAccount = payable(_feeAccount);

        _primaryPlatformBPs = 1300; // 13% fee on primary sales paid to  marketplace (artist receives the remainder, 90%)
        _secondaryPlatformBPs = 300; // 3% fee on all sales paid to marketplace
    }
}
